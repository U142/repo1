package parm.xml;

//Parm packages

import parm.voobjects.*;
import parm.constants.*;
import parm.exception.ParmException;
//Packages to work with filestreams
import java.io.*;
import java.util.*;
import java.util.zip.*;
//Packages to work with xml
import org.w3c.dom.*;
import javax.xml.parsers.*;
import org.xml.sax.*;
import parm.main.MainController;

public class XmlReader {

	private ZipInputStream zip;
	private XmlPolyReader polyReader;
	private XmlWriter writer;
	private InputStream xmlStream;
	private DocumentBuilderFactory docBuilderFactory;
	private DocumentBuilder docBuilder;
	private Document doc;
	//private MapPanel map;
	private ArrayList arrayCategories;
	private ArrayList arrayEvents;
	private ArrayList arrayObjects;
	private ArrayList arrayAlerts;
	private Collection objectList;
	private NodeList listOfObjects;
	private String timestamp;
	private ArrayList pkListe, tempPkListe;
	private MainController main;

	public XmlReader(MainController main) {
		super();
		zip = null;
		writer = null;
		pkListe = null;
		tempPkListe = null;
		this.main = main;
	}

	public Collection readXml() throws ParmException {
		/*
		 * Goes through xml file and collects objects,events, alerts to a
		 * collection. This collection is to be used in tree
		 */
		this.pkListe = new ArrayList();
		//this.map = map;
		this.objectList = new ArrayList();
		this
				.getXmlFromZip(ParmConstants.parmXmlName,
						ParmConstants.xmlLocation);
		if (this.xmlStream != null) {
			this.parseXmlDocument();
			this.paCategory();
			this.listOfObjects = null;
			this.paEvent(true); // False indicates that it is a update xml read
			this.sortListAscending(arrayEvents);
			this.listOfObjects = null;
			this.paAlert(true); // True indeicates that it is a normal xml read
			this.sortListAscending(arrayAlerts);
			this.listOfObjects = null;
			this.paObjects(true);
			this.sortListAscending(arrayObjects);
			this.listOfObjects = null;
			this.readPolyXml();
			
			this.sortArrays();

			objectList.addAll(arrayCategories);
			objectList.addAll(arrayObjects);
		}

		return objectList;
	}

	public Collection readResponseXml(InputStream in) throws ParmException {
		//this.map = map;
		this.doc = null;
		this.xmlStream = in;
		this.pkListe = new ArrayList();
		this.tempPkListe = new ArrayList();
		this.writeXmlFromStream(in, ParmConstants.resZipLocation);
		this.getXmlFromZip(ParmConstants.parmXmlName,
				ParmConstants.resZipLocation);
		this.parseXmlDocument();
		writer = new XmlWriter();
		if (doc != null) {
			NodeList responseList = doc.getElementsByTagName("responsecodes");
			NodeList updateList = doc.getElementsByTagName("updates");
			this.readResponseXml(responseList, updateList);
		}
		try{
			File file = new File(ParmConstants.resZipLocation);
			file.delete();
		}catch(Exception io){
			System.out.println("Klarte ikke slette "+ParmConstants.resZipLocation+" filen!");
		}
		return this.objectList;
	}

	public Collection readTempXml(XmlWriter writer) throws ParmException {
		this.objectList = new ArrayList();
		this.getXmlFromZip("parmxml.xml", ParmConstants.xmlLocation);
		if (this.xmlStream != null) {
			this.parseXmlDocument();
			timestamp = doc.getDocumentElement().getAttribute("l_timestamp");
			writer.setRootTimestamp(timestamp);
			this.paEvent(false);
			this.sortListAscending(arrayEvents);
			this.paAlert(false);
			this.sortListAscending(arrayAlerts);
			this.paObjects(false);
			this.sortListAscending(arrayObjects);
			this.readPolyXml();

			if (!arrayObjects.isEmpty()){
				sortListAscending(arrayObjects);
				objectList.addAll(arrayObjects);
			}
			if (!arrayEvents.isEmpty()){
				sortListAscending(arrayEvents);
				objectList.addAll(arrayEvents);
			}
			if (!arrayAlerts.isEmpty()){
				sortListAscending(arrayAlerts);
				objectList.addAll(arrayAlerts);
			}
		}
		if (objectList.isEmpty())
			return null;
		else
			return objectList;
	}

	public String getRootTimestamp() throws ParmException {
		this
				.getXmlFromZip(ParmConstants.parmXmlName,
						ParmConstants.xmlLocation);
		this.parseXmlDocument();
		Node node = doc.getFirstChild();
		Element el = (Element) node;
		this.timestamp = el.getAttribute("l_timestamp");
		return this.timestamp;
	}

	public Collection getResponseList() {
		return this.objectList;
	}

	private void readPolyXml() throws ParmException {
		this.docBuilderFactory = null;
		this.docBuilder = null;
		this.doc = null;
		this.getXmlFromZip(ParmConstants.polyXmlName,
						ParmConstants.xmlLocation);
		this.parseXmlDocument();

		if (doc != null) {
			this.polyReader = new XmlPolyReader(doc, main);
			this.polyReader.readPolyObject(this.arrayObjects);
			this.polyReader.readPolyAlert(this.arrayAlerts);
		}
	}

	private void readResponseCodes() {

		for (int i = 0; i < listOfObjects.getLength(); i++) {
			String objectpk, tempPk, status, timestamp;

			Node object = listOfObjects.item(i);
			Element element = (Element) object;
			objectpk = element.getAttribute("l_objectpk");
			tempPk = element.getAttribute("l_temppk");
			status = element.getAttribute("sz_status");
			timestamp = element.getAttribute("l_timestamp");
			if (status.compareTo("S_OK") == 0) { // Checks if the operation
				// was ok at the Database
				int check = writer.updateXml(objectpk, tempPk, timestamp);
				if (check == 0) {
					System.out.println(objectpk
							+ " is now updated in the local xml file!");
					this.pkListe.add(objectpk);
					this.tempPkListe.add(tempPk);
				} else {
					System.out.println(objectpk
							+ " didnt get updated in the local xml file!");
				}
				check = writer.updatePolyXml(objectpk, tempPk);
				if (check == 0) {
					System.out.println(objectpk
							+ " is now updated in the local xml file!");
					this.pkListe.add(objectpk);
					this.tempPkListe.add(tempPk);
				} else {
					System.out.println(objectpk
							+ " didnt get updated in the local xml file!");
				}
			} else {
				System.out.println(element.getNodeValue());
			}
		}
	}

	private void readResponseXml(NodeList responseList, NodeList updateList)
			throws ParmException {
		// Get elements updated by this user
		this.objectList.clear();
		Node responseNode = responseList.item(0);
		Element responseElement = (Element) responseNode;
		if (responseElement.hasChildNodes()) {
			// Work responsecodes
			this.listOfObjects = responseElement
					.getElementsByTagName(ParmConstants.xmlElmObject);
			this.readResponseCodes();

			this.listOfObjects = responseElement
					.getElementsByTagName(ParmConstants.xmlElmEvent);
			this.readResponseCodes();

			this.listOfObjects = responseElement
					.getElementsByTagName(ParmConstants.xmlElmAlert);
			this.readResponseCodes();
		}
		// Get elements created from other users
		Node updatesNode = updateList.item(0);
		Element updateElement = (Element) updatesNode;

		if (updateElement.hasChildNodes()) {
			// Get new items
			this.listOfObjects = updateElement
					.getElementsByTagName(ParmConstants.xmlElmCat);
			this.paCategory();

			this.listOfObjects = updateElement
					.getElementsByTagName(ParmConstants.xmlElmObject);
			this.paObjects(true);
			this.sortListAscending(arrayObjects);
			this.listOfObjects = updateElement
					.getElementsByTagName(ParmConstants.xmlElmEvent);
			this.paEvent(true);
			this.sortListAscending(arrayEvents);
			this.listOfObjects = updateElement
					.getElementsByTagName(ParmConstants.xmlElmAlert);
			this.paAlert(true);
			this.sortListAscending(arrayAlerts);
			
			//Hent ut polygoner som skal legges til objektene
			doc = null; 
			docBuilder = null; 
			docBuilderFactory = null;
			this.getXmlFromZip(ParmConstants.polyXmlName,ParmConstants.resZipLocation); 
			this.parseXmlDocument();
			Collection col = null;
			if (doc != null) { 
				this.polyReader = new XmlPolyReader(doc, main);
				this.polyReader.readPolyObject(this.arrayObjects);
				this.polyReader.readPolyAlert(this.arrayAlerts);
				//n00b! col = this.polyReader.getUpdatedList();
				//this.objectList.addAll(this.polyReader.getUpdatedList());
			}
			// Legg lister inn i object collection
			if(col==null){//Dersom det ikke finnes polygonfil
				this.objectList.addAll(this.arrayObjects);
				this.objectList.addAll(this.arrayAlerts);
				
			}
			else//Legg til alle objektene som har vert i sjekk mot polyon filen
				this.objectList.addAll(col);
			
			this.objectList.addAll(this.arrayEvents);
			this.objectList.addAll(this.arrayCategories);

		}

		if (this.objectList != null) {
			this.timestamp = updateElement.getAttribute("l_timestamp");
			writer.setRootTimestamp(this.timestamp);
			//Prøver å tømme polyxml slik at det ikke blir lagret dobbelt.
			//writer.writeEmptyPoly(ParmConstants.polyXmlName);
			this.writer.writeXml(this.objectList);
		}
		this.listOfObjects = null;
		// Legg til de oppdaterte elementene i xml filen til objectListen
		updateMemObjects();
	}

	private void updateMemObjects() throws ParmException {
		resetXmlStream();
		getXmlFromZip(ParmConstants.parmXmlName, ParmConstants.xmlLocation);
		parseXmlDocument();

		// Henter xml filens elementer og legger i lister, arrayCategories,
		// arrayEvents, arrayObjects og arrayAlerts
		// this.paCategory(); Trenger bare om categorier skal bli oppdatert
		// this.listOfObjects = null;
		this.paEvent(true);
		this.sortListAscending(arrayEvents);// False indicates that it is a update xml read
		this.listOfObjects = null;
		this.paAlert(true); // True indeicates that it is a normal xml read
		this.sortListAscending(arrayAlerts);
		this.listOfObjects = null;
		this.paObjects(true);
		this.sortListAscending(arrayObjects);
		this.listOfObjects = null;
		// Går igjennom alle pk og sjekker mot objects, events, alerts
		if (!pkListe.isEmpty() && !this.objectList.isEmpty()) {
			for (int i = 0; i < this.pkListe.size(); i++) {
				String pk = (String) this.pkListe.get(i);
				String tempPk = (String) this.tempPkListe.get(i);
				// Går igjennom objects
				ArrayList tempListe = (ArrayList) this.objectList;
				for (int o = 0; o < tempListe.size(); o++) {
					// MÅ gå igjennom objecter,events og alerts i denne løkken!
					Object obj = tempListe.get(o);
					if (obj.getClass().equals(ObjectVO.class)) {
						ObjectVO oVO = (ObjectVO) obj;
						if (oVO.getObjectPK().compareTo(pk) == 0) {
							oVO.setTempPk(tempPk);
							break;
						}
					} else if (obj.getClass().equals(EventVO.class)) {
						EventVO eVO = (EventVO) obj;
						if (eVO.getEventPk().compareTo(pk) == 0) {
							eVO.setTempPk(tempPk);
							break;
						}
					} else if (obj.getClass().equals(AlertVO.class)) {
						AlertVO aVO = (AlertVO) obj;
						if (aVO.getAlertpk().compareTo(pk) == 0) {
							aVO.setTempPk(tempPk);
							break;
						}
					}
				}
			}
		}
		this.pkListe = null;
	}

	private void paObjects(boolean normalRead) {
		arrayObjects = new ArrayList();
		if (this.listOfObjects == null)
			this.listOfObjects = doc
					.getElementsByTagName(ParmConstants.xmlElmObject);

		for (int i = 0; i < listOfObjects.getLength(); i++) {
			boolean isFolder;
			String objectpk, parent, categorypk;
			String name, description, address, postno, place, phone, metadata, timestamp;
			String temp;

			Node objects = listOfObjects.item(i);
			Element eAttributes = (Element) objects;

			if (eAttributes.hasAttribute("sz_operation") || normalRead) {
				temp = eAttributes.getAttribute(ParmConstants.xmlElmObjectPk);
				if (temp.length() > 0)
					objectpk = temp;
				else
					objectpk = "-1";
				// Legg til pk i pklisten
				// this.pkListe.add(objectpk);

				temp = eAttributes.getAttribute("l_parent");
				if (temp.length() > 0)
					parent = temp;
				else
					parent = "-1";

				temp = eAttributes.getAttribute("f_isobjectfolder");
				if (temp.length() > 0) {
					if (Integer.parseInt(temp) == 1)
						isFolder = true;
					else
						isFolder = false;
				} else
					isFolder = true;

				name = eAttributes.getAttribute("sz_name");
				description = eAttributes.getAttribute("sz_description");
				address = eAttributes.getAttribute("sz_address");
				postno = eAttributes.getAttribute("sz_postno");
				place = eAttributes.getAttribute("sz_place");
				phone = eAttributes.getAttribute("sz_phone");
				metadata = eAttributes.getAttribute("sz_metadata");
				timestamp = eAttributes.getAttribute("l_timestamp");

				ObjectVO oo = new ObjectVO(objectpk, name, description, parent,
						address, postno, place, phone, metadata, timestamp,
						isFolder);
				if (eAttributes.hasAttribute("sz_operation"))
					oo.setOperation(eAttributes.getAttribute("sz_operation"));

				temp = eAttributes.getAttribute("l_deptpk");
				if (temp.length() > 0)
					oo.setDeptPK(temp);
				else
					oo.setDeptPK("1");

				temp = eAttributes.getAttribute("l_importpk");
				if (temp.length() > 0)
					oo.setImportPK(temp);

				temp = eAttributes.getAttribute(ParmConstants.xmlElmCatPk);
				if (temp.length() > 0) {
					categorypk = temp;
					oo.setCategoryPK(categorypk);
				} else
					categorypk = "-1";

				if (normalRead) {
					CategoryVO co = null;
					Iterator it = arrayCategories.iterator();
					while (it.hasNext()) {
						co = (CategoryVO) it.next();
						if (co.getCategoryPK().compareTo(categorypk) == 0
								&& categorypk.compareTo("-1") != 0) {
							break;
						} else
							co = null;
					}
					if (co != null)
						oo.setCategoryVO(co);
				}
				temp = null;
				if (eAttributes.hasAttribute("sz_operation") && normalRead) {
					if (eAttributes.getAttribute("sz_operation").compareTo(
							"delete") == 0) {

					} else
						arrayObjects.add(oo);
				} else
					arrayObjects.add(oo);
			}
		}
		this.listOfObjects = null;
	}

	private void paEvent(boolean normalRead) {
		arrayEvents = new ArrayList();
		if (this.listOfObjects == null)
			this.listOfObjects = doc
					.getElementsByTagName(ParmConstants.xmlElmEvent);

		for (int i = 0; i < this.listOfObjects.getLength(); i++) {

			String name, categorypk, objectpk, description, timestamp, eventPk;
			String temp;

			Node event = this.listOfObjects.item(i);
			Element eAttributes = (Element) event;
			if (eAttributes.hasAttribute("sz_operation") || normalRead) {
				temp = eAttributes.getAttribute(ParmConstants.xmlElmEventPk);
				if (temp.length() > 0)
					eventPk = temp;
				else
					eventPk = "-1";
				temp = eAttributes.getAttribute("l_parent");
				if (temp.length() > 0) {
					objectpk = temp;
				} else
					objectpk = "-1";
				name = eAttributes.getAttribute("sz_name");
				description = eAttributes.getAttribute("sz_description");
				timestamp = eAttributes.getAttribute("l_timestamp");

				EventVO eo = new EventVO(eventPk, objectpk, name, description,
						timestamp);

				if (eAttributes.hasAttribute("sz_operation"))
					eo.setOperation(eAttributes.getAttribute("sz_operation"));

				temp = eAttributes.getAttribute(ParmConstants.xmlElmCatPk);
				if (temp.length() > 0) {
					categorypk = temp;
					eo.setCategorypk(categorypk);
				} else
					categorypk = "-1";
				temp = null;
				CategoryVO co = null;
				if (normalRead) {
					Iterator it = arrayCategories.iterator();
					while (it.hasNext()) {
						co = (CategoryVO) it.next();
						if (co.getCategoryPK().compareTo(categorypk) == 0
								&& categorypk.compareTo("-1") != 0) {
							break;
						} else
							co = null;
					}
					if (co != null)
						eo.setCatVO(co);
				}
				if (eAttributes.hasAttribute("sz_operation") && normalRead) {
					if (eAttributes.getAttribute("sz_operation").compareTo(
							"delete") == 0) {

					} else
						arrayEvents.add(eo);
				} else
					arrayEvents.add(eo);
			}
		}
		this.listOfObjects = null;
	}

	private void paAlert(boolean normalRead) {
		arrayAlerts = new ArrayList();

		if (this.listOfObjects == null)
			this.listOfObjects = doc
					.getElementsByTagName(ParmConstants.xmlElmAlert);

		for (int i = 0; i < this.listOfObjects.getLength(); i++) {

			int addresstypes;
			String alertPk, parent, name, description, oadc, timestamp;
			String temp;

			Node alert = this.listOfObjects.item(i);
			Element eAttributes = (Element) alert;
			if (eAttributes.hasAttribute("sz_operation") || normalRead) {
				// Gets the integers and checks for "" values
				temp = eAttributes.getAttribute(ParmConstants.xmlElmAlertPk);
				if (temp.length() > 0)
					alertPk = temp;
				else
					alertPk = "-1";

				temp = eAttributes.getAttribute("l_parent");
				if (temp.length() > 0)
					parent = temp;
				else
					parent = "-1";

				temp = eAttributes.getAttribute("l_addresstypes");
				if (temp.length() > 0)
					addresstypes = Integer.parseInt(temp);
				else
					addresstypes = -1;
				name = eAttributes.getAttribute("sz_name");
				description = eAttributes.getAttribute("sz_description");
				oadc = eAttributes.getAttribute("sz_oadc");
				timestamp = eAttributes.getAttribute("l_timestamp");

				AlertVO ao = new AlertVO(alertPk, parent, name, addresstypes/*
																			 * ,
																			 * this.map,
																			 * this.map.getM_navigation()
																			 */);

				if (eAttributes.hasAttribute("sz_operation"))
					ao.setOperation(eAttributes.getAttribute("sz_operation"));

				ao.setDescription(description);
				ao.setTimestamp(timestamp);
				ao.setOadc(oadc);
				temp = eAttributes.getAttribute("l_profilepk");
				if (temp.length() > 0)
					ao.setProfilepk(Integer.parseInt(temp));

				temp = eAttributes.getAttribute("l_schedpk");
				if (temp.length() > 0)
					ao.setSchedpk(Integer.parseInt(temp));

				temp = eAttributes.getAttribute("l_validity");
				if (temp.length() > 0)
					ao.setValidity(Integer.parseInt(temp));

				temp = null;

				if (eAttributes.hasAttribute("sz_operation") && normalRead) {
					if (eAttributes.getAttribute("sz_operation").compareTo(
							"delete") == 0) {

					} else
						arrayAlerts.add(ao);
				} else
					arrayAlerts.add(ao);
			}
		}
		this.listOfObjects = null;
	}

	private void paCategory() {
		arrayCategories = new ArrayList();

		if (this.listOfObjects == null)
			this.listOfObjects = doc
					.getElementsByTagName(ParmConstants.xmlElmCat);

		for (int i = 0; i < this.listOfObjects.getLength(); i++) {
			String categoryPk;
			String name, description, fileext, timestamp;
			String temp;

			Node categories = this.listOfObjects.item(i);
			Element eAttributes = (Element) categories;
			temp = eAttributes.getAttribute(ParmConstants.xmlElmCatPk);
			if (temp.length() > 0)
				categoryPk = temp;
			else
				categoryPk = "-1";
			name = eAttributes.getAttribute("sz_name");
			description = eAttributes.getAttribute("sz_description");
			fileext = eAttributes.getAttribute("sz_fileext");
			timestamp = eAttributes.getAttribute("l_timestamp");

			temp = null;
			// Put category object in collection
			arrayCategories.add(new CategoryVO(categoryPk, name, description,
					fileext, timestamp));
		}

	}

	private void sortArrays() {
		// Denne metoden sorterer alle listene slik at alt blir lagt tilhørende
		// de rette objekter.
		
		Iterator it;
		// Put the alerts into the right events
		if (arrayEvents != null && arrayAlerts != null) {
			it = arrayEvents.iterator();
			while (it.hasNext()) {
				EventVO eo = (EventVO) it.next();
				Iterator italert = arrayAlerts.iterator();
				while (italert.hasNext()) {
					AlertVO ao = (AlertVO) italert.next();
					if (ao.getParent().compareTo(eo.getEventPk()) == 0)
						eo.addAlerts(ao);
				}
			}
		}
		// Put the categories into the right event
		if (arrayEvents != null) {
			it = arrayEvents.iterator();
			while (it.hasNext()) {
				EventVO eo = (EventVO) it.next();
				Iterator itCat = arrayCategories.iterator();
				while (itCat.hasNext()) {
					CategoryVO co = (CategoryVO) itCat.next();
					if (eo.getCategorypk().compareTo(co.getCategoryPK()) == 0)
						eo.setCatVO(co);
				}
			}
		}
		// Put events into the right object
		it = arrayObjects.iterator();
		while (it.hasNext()) {
			ObjectVO oo = (ObjectVO) it.next();
			Iterator itEvent = arrayEvents.iterator();
			while (itEvent.hasNext()) {
				EventVO eo = (EventVO) itEvent.next();
				if (eo.getParentpk().compareTo(oo.getObjectPK()) == 0)
					oo.addEvents(eo);
			}
		}
		// Put the categories into the right object
		it = arrayObjects.iterator();
		while (it.hasNext()) {
			ObjectVO oo = (ObjectVO) it.next();
			Iterator itCat = arrayCategories.iterator();
			while (itCat.hasNext()) {
				CategoryVO co = (CategoryVO) itCat.next();
				if (oo.getCategoryPK().compareTo(co.getCategoryPK()) == 0)
					oo.setCategoryVO(co);
			}
		}
		// Put the objects into the right objects
		it = arrayObjects.iterator();
		while (it.hasNext()) {
			ObjectVO oo = (ObjectVO) it.next();
			Iterator itObj = arrayObjects.iterator();
			while (itObj.hasNext()) {
				ObjectVO temp = (ObjectVO) itObj.next();
				if (oo.getObjectPK().compareTo(temp.getParent()) == 0)
					oo.addObjects(temp);
			}
		}
		int size = arrayObjects.size() - 1;
		for (int i = size; i >= 0; i--) {
			ObjectVO temp = (ObjectVO) arrayObjects.get(i);
			if (temp.getParent().compareTo("o-1") != 0)
				arrayObjects.remove(i);
		}
	}
	private void sortListAscending(ArrayList liste){
		ListComparator comp = new ListComparator();
		Collections.sort(liste,comp);
	}
	
	private void writeXmlFromStream(InputStream in, String outPutFileName) throws ParmException {
		try {
			int len;
			byte[] buffer = new byte[1024];
				OutputStream out = new BufferedOutputStream(new FileOutputStream(outPutFileName));
				while ((len = in.read(buffer)) >= 0)
					out.write(buffer, 0, len);

				//in.close();
				out.close();
		} catch (IOException io) {
			io.printStackTrace();
			throw new ParmException(
					"XmlReader:There has occured an stream error;");
		}
	}

	private void getXmlFromZip(String filename, String zipname)
			throws ParmException {
		// Get the xml file specified by filename from parmxml zip file
		File xmlfile = new File(zipname);

		if (xmlfile.exists()) {
			try {
				ZipFile zipfile = new ZipFile(xmlfile);
				Enumeration en = zipfile.entries();
				while (en.hasMoreElements()) {
					ZipEntry entry = (ZipEntry) en.nextElement();
					String navn = entry.getName();
					navn = navn.substring(0,8);
					if(filename.compareTo(ParmConstants.parmXmlName)== 0 && navn.compareTo("parmroot")==0){
						xmlStream = zipfile.getInputStream(entry);
						break;
					}
					else if(filename.compareTo(ParmConstants.polyXmlName)== 0 && navn.compareTo("parmpoly")==0){
						xmlStream = zipfile.getInputStream(entry);
						break;
					}
					else if (entry.getName().compareTo(filename) == 0){
						xmlStream = zipfile.getInputStream(entry);
						break;
					}
				}
			} catch (ZipException ze) {
				throw new ParmException(
						"XmlReader:Error while reading from zip file;");
			} catch (IOException io) {
				throw new ParmException(
						"XmlReader:There has occured an stream error;");
			} finally {
				try {
					if (zip != null) {
						zip.close();
					}
				} catch (IOException ioe) {
					System.out.println("Error while closing filestream: "
							+ ioe.getMessage());
				}
			}
		} else {
			this.writer = new XmlWriter();
			this.writer.writeXml(null);
		}
	}

	private void parseXmlDocument() throws ParmException {
		try {
			docBuilderFactory = DocumentBuilderFactory.newInstance();
			docBuilder = docBuilderFactory.newDocumentBuilder();
			doc = docBuilder.parse(xmlStream);
		} catch (FactoryConfigurationError fce) {
			throw new ParmException(
					"XmlReader:Implementation of the factory is not available or could not be instantiated;");
		} catch (ParserConfigurationException pce) {
			throw new ParmException(
					"XmlReader:Documentbuilder could not be created;");
		} catch (SAXException saxe) {
			throw new ParmException(
					"XmlReader:The xml document is not in a valid format;");
		} catch (IOException ioe) {
			throw new ParmException(
					"XmlReader:There has occured an stream error;");
		}

	}

	private void resetXmlStream() {
		if (xmlStream != null) {
			try {
				xmlStream.close();
			} catch (IOException io) {
				System.out.println("XmlReader-->updateMemObjects()"
						+ io.getMessage());
			}
			doc = null;
			docBuilder = null;
			docBuilderFactory = null;
		}
	}
}
